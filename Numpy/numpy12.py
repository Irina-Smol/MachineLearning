import numpy as np

# Множества (unique) и операции над ними

# в множествах все значения должны быть уникальными и представленными в единственном варианте
a = np.array([1, 2, 3, 4, 4, 3, 2, 1])

# Чтобы преобразовать массив a в множество используется функция unique
setA = np.unique(a) # array([1, 2, 3, 4])

# У функции unique есть несколько полезных параметров. Первый из них return_counts:
np.unique(a, return_counts=True) # (array([1, 2, 3, 4]), array([2, 2, 2, 2]))
                       # позволяет возвращать не только уникальные значения, но и число их вхождений в исходном массиве a

# Следующий параметр return_index позволяет определять индексы первого вхождения уникальных элементов в исходном массиве:
np.unique(a, return_index=True) # (array([1, 2, 3, 4]), array([0, 1, 2, 3]))

# третий параметр return_inverse возвращает индексы, по которым можно точно восстановить исходный массив
np.unique(a, return_inverse=True) # (array([1, 2, 3, 4]), array([0, 1, 2, 3, 3, 2, 1, 0], dtype=int32))
#  здесь 1 у множества имеет индекс 0 и во втором массиве стоят нули там, где должна быть 1. И так для всех значений.

# восстановление исходного массива a
setA, indx = np.unique(a, return_inverse=True)
aa = setA[indx] # array([1, 2, 3, 4, 4, 3, 2, 1])

# Функция unique также может работать и с многомерными массивами
x = np.array([[0, 1, 1, 2],[0, 1, 1, 2],[9, 1, 1, 2]])
np.unique(x) # array([0, 1, 2, 9])

#  дополнительно указывать оси, по которым будет происходить отбор уникальных значений
np.unique(x, axis=0)
# array([[0, 1, 1, 2],
#        [9, 1, 1, 2]])

# использовалась первая ось, то есть, определялись уникальные строки. Если указать вторую ось:
np.unique(x, axis=1)
# то получим уникальные столбцы:

#array([[0, 1, 2],
#       [0, 1, 2],
#       [9, 1, 2]])

# Операции над множествами

# В NumPy есть несколько функций для выполнения базовых операций с множествами.
# Первая – это проверка вхождений элементов одного множества в другое.
# Например, заданы два массива с уникальными значениями (множества):

x = np.array([0, 1, 2, 3])
y = np.array([1, 2, 3, 4, 5, 6, 7, 8])

np.in1d(x, y) # array([False,  True,  True,  True])
# На выходе получим массив булевых значений и там где стоит False означает отсутствие элемента, True – наличие совпадения

np.random.shuffle(y) # array([5, 8, 4, 6, 2, 7, 3, 1])
np.in1d(x, y) # array([False,  True,  True,  True])

# Пересечение множеств (пределение значений, которые входят в оба множества одновременно)
np.intersect1d(x, y) # array([1, 2, 3])

# Объединение множеств (уникальные числа, которые входят в оба множества)
np.union1d(x, y) # array([0, 1, 2, 3, 4, 5, 6, 7, 8])

# Вычитание множеств
np.setdiff1d(x, y) # array([0])
np.setdiff1d(y, x) # array([4, 5, 6, 7, 8])

# Симметричная разность (XOR) (остаются не совпадающие значения из двух множеств)
np.setxor1d(x, y) # array([0, 4, 5, 6, 7, 8])
