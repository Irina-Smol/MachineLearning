import numpy as np

a = np.arange(1, 10).reshape(3, 3)
b = np.arange(10, 19).reshape(3, 3)
print(a*b)

# В консоли увидим результат:
# array([[ 10,  22,  36],
#        [ 52,  70,  90],
# [112, 136, 162]])

# Матричное умножение

# Но если нам нужно выполнить именно матричное умножение, то есть, строки одной матрицы умножать на столбцы другой и
# результаты складывать:

np.dot(a, b) # функция возвращает новую матрицу (двумерный массив) с результатом умножения

# array([[ 84,  90,  96],
# [201, 216, 231],
# [318, 342, 366]])

# Тот же результат можно получить и с помощью функции:

np.matmul(a, b)

# Векторное умножение

# Аналогичные операции можно выполнять и с векторами
a = np.arange(1, 10)
b = np.ones(9)
np.dot(a, b) # значение 45

# более предпочтительной функцией для внутреннего умножения векторов
np.inner(a, b) # 45

# Второй вариант умножения (внешнее умножение векторов) реализуется с помощью функции
np.outer(a, b)

# array([[1., 1., 1., 1., 1., 1., 1., 1., 1.],
#        [2., 2., 2., 2., 2., 2., 2., 2., 2.],
#        [3., 3., 3., 3., 3., 3., 3., 3., 3.],
#        [4., 4., 4., 4., 4., 4., 4., 4., 4.],
#        [5., 5., 5., 5., 5., 5., 5., 5., 5.],
#        [6., 6., 6., 6., 6., 6., 6., 6., 6.],
#        [7., 7., 7., 7., 7., 7., 7., 7., 7.],
#        [8., 8., 8., 8., 8., 8., 8., 8., 8.],
# [9., 9., 9., 9., 9., 9., 9., 9., 9.]])

# в пакете NumPy имеется весьма полезный перегруженный оператор, заменяющий функцию matmul:

print(a @ b) # значение 45

# или, с использованием матриц:

a.resize(3, 3)
b.resize(3, 3)
print(a @ b) # аналог np.matmul(a, b)

# Умножение вектора на матрицу

# зададим одномерный вектор и двумерную матрицу:
a = np.array([1, 2, 3])
b = np.arange(4, 10).reshape(3, 2) # матрица 3x2

np.dot(a, b) # array([40, 46])
# когда одномерный массив записан первым аргументом, а матрица – вторым, получаем умножение вектора-строки на матрицу

a = np.array([1, 2])
np.dot(b, a) # array([14, 20, 26])
a.shape = -1, 1 # вектор-столбец 2x1
np.dot(b, a) # вектор-столбец 3x1
print(a @ b) # вектор-столбец 3x1

# Элементы линейной алгебры

a = np.array([(1, 2, 3), (1, 4, 9), (1, 8, 27)])

# вычислим ранг этой матрицы, чтобы быть уверенным, что она состоит из линейно независимых строк и столбцов
np.linalg.matrix_rank(a) # ранг равен 3

# Если ранг матрицы совпадает с ее размерностью, значит, она способна описывать систему из трех независимых линейных уравнений
y = np.array([10, 20, 30])
np.linalg.solve(a, y) # array([-5.  , 10.   , -1.66666667]) корни уравнения можно вычислить с помощью функции solve

invA = np.linalg.inv(a) # вычисление обратной матрицы
print(invA @ y) # вычисление корней

# linalg.cholesky() - Разложение Холецкого
# linalg.qr() - QR-разложение матрицы
# linalg.svd() - Сингулярное (SVD) разложение матрицы
# linalg.norm() - Норма матрицы или вектора
# linalg.cond() - Число обусловленности матрицы
# linalg.det() - Определитель (детерминант) матрицы
# linalg.matrix_rank() - Вычисление ранга матрицы по алгоритму SVD
# np.trace() - Сумма диагональных элементов массива
# linalg.eig() - Вычисление собственных значений и правых собственных векторов
# linalg.eigvals() - Вычисление собственных значений матрицы
# linalg.solve() - Решение линейного матричного уравнения
# linalg.tensorsolve() - Решение линейного тензорного уравнения
# linalg.lstsq() - Решает задачу поиска наименьших квадратов для линейного матричного уравнения
# linalg.inv() - Вычисление обратной матрицы
# linalg.pinv() - Вычисление псевдообратной (Мура-Пенроуза) матрицы
# linalg.tensorinv() - Вычисление обратного тензора (N-мерного массива)
