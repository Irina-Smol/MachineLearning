import numpy as np

# Индексация, срезы, итерирование массивов

a = np.arange(12) # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

print(a[2])  #  увидим значение 2
print(a[-1])  # последнее значение 11
print(a[-2])  # предпоследнее значение 10

#print(a[12]) # ошибка, последний индекс 11
a[0] = 100  # первый элемент равен 100

b = a[2:4] # array([2, 3])
b[0] = -100 # и это приводит к изменению соответствующего элемента массива a:
                       # array([ 100,  1, -100,    3,    4,    5,    6,    7,    8,    9,   10,   11])
                        # Поэтому срезы – это не копии массивов, а лишь создание их нового представления

print(a[3:]) # array([ 3,  4,  5,  6,  7,  8,  9, 10, 11])
print(a[:5]) # array([ 100,    1, -100,   3,    4])
print(a[-5: -1]) # array([ 7,  8,  9, 10])
print(a[:]) # array([ 100,    1, -100,    3,   4,    5,    6,    7,    8,    9,   10,   11])
print(a[1:6:2]) # array([1, 3, 5])
print(a[::2]) # array([ 100, -100,    4,   6,    8,   10])
print(a[::-1]) # array([  11,   10,    9,    8,    7,    6,    5,    4,    3, -100,  1,  100])

a[:4] = [-1, -2, -3, -4] # присваивание списка Python
a[4::2] = np.array([10, 20, 30, 40]) # присваивание массива NumPy

print(a)

# массивы – итерируемые объекты
for x in a:
     print(x, sep=' ', end=' ')


# Индексация и срезы многомерных массивов

x = np.array([(1, 2, 3), (10, 20, 30), (100, 200, 300)])
print(x[1, 1])  # значение 20
print(x[-1, -1]) # значение 300
print(x[0]) # array([1, 2, 3])
print(x[0, :]) # array([1, 2, 3])
# Для извлечения столбцов мы уже должны явно указать полный срез в качестве первого индекса:
print(x[:,1]) # array([  2,  20, 200])

# Итерирование двумерных массивов можно выполнять с помощью вложенных циклов
for row in x:
    for val in row:
        print(val, end=' ')
    print()
# Если же необходимо просто перебрать все элементы многомерного массива, то можно использовать свойство flat
for val in x.flat:
    print(val, end=' ')

# У массивов более высокой размерности картина индексации, в целом выглядит похожим образом. Например,
# создадим четырехмерный массив:
a = np.arange(1, 82).reshape(3, 3, 3, 3)
print(a)
print(a[1, 2, 0, 1]) # число 47
print(a[:, 1, :, :]) # матрица 3x3x3 (Для выделения многомерного среза)
print(a[0, 0]) # двумерная матрица 3x3
print(a[0, 0, :, :])
# Если же нужно задать два последних индекса, то полные срезы у первых двух осей указывать обязательно
print(a[:, :, 1, 1]) # матрица 3x3
print(a[0:2, 0:2, 1, 1]) # матрица 2x2

# Пакет NumPy позволяет множество полных подряд идущих срезов заменять троеточиями.
# Например, вместо a[:, :, 1, 1] можно использовать запись:
print(a[..., 1, 1]) # эквивалент a[:, :, 1, 1]


# Списочная индексация
# еще один способ индексирования – через списки или массивы целых чисел

a = np.arange(1, 9) # array([1, 2, 3, 4, 5, 6, 7, 8])
# если указать обычный числовой индекс, то получим одно значение соответствующего элемента
print(a[0]) # значение 1

# если вместо числового индекса указать список, то на выходе уже получим копию массива из одного первого значения исходного
b = a[[0]] # array([1])
b[0] = 100 # Изменение массива b не приведет к изменению данных в массиве a.
print(a[[0, 1, 7, 5]]) # array([1, 2, 8, 6])

print(a[[0, 0, 1, 1, 1, 2, 3, 4, 5, 6, 7]]) # array([1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8])

# Копия массива через списочное индексирование создается, когда выражение записано справа от бинарного оператора
# (является выражением типа rvalue).
# Если же такую же конструкцию записать слева от оператора (как выражение lvalue):
a[[0, 1, 2]] = [10, 20, 30]
# то копия не создается, а просто в элементы этого же массива с индексами 0, 1 и 2 заносятся значения 10, 20 и 30

# Кроме обычных списков языка Python мы можем передавать и массивы NumPy, состоящие из целых значений
indx = np.array([0, 0, 1, 1, 1, 2])
print(a[indx]) # array([1, 1, 2, 2, 2, 3])

bIndx = [True, True, False, False, False, True, False, False]
print(a[bIndx]) # array([1, 2, 6])

i = a > 5 # array([False, False, False, False, False,  True,  True,  True])
print(a[i]) # array([6, 7, 8])
print(a[a > 5]) # array([6, 7, 8])


# Списочная индексация и многомерные массивы

# если взять тот же одномерный массив
a = np.arange(1, 9)
# но набор индексов определить как двумерный массив
i = np.array([[0, 1], [2, 3]])
# то на выходе будет формироваться уже двумерный массив
print(a[i]) # array([[1, 2], [3, 4]])

a = np.arange(1, 13).reshape(3, 4)
indx = [2, 1, 0]
print(a[indx])
# >>>array([[ 9, 10, 11, 12],
#       [ 5,  6,  7,  8],
#        [ 1,  2, 3,  4]])
# здесь индексы обозначают номера строк двумерного массива. В результате, строки нового массива идут в обратном порядке
indx = np.array([[1, 0], [2, 1]])
print(a[indx])
# >>>Результатом будет трехмерный массив:
# array([[[ 5,  6,  7,  8],
#         [ 1,  2,  3,  4]],
#
#        [[ 9, 10, 11, 12],
#         [ 5,  6,  7,  8]]])

# Если же мы хотим выбирать из двумерного массива не строки, а отдельные элементы и на их основе формировать новые массивы,
# то следует использовать два списка. Первый список по прежнему будет указывать строки массива,
# а второй – индексы столбцов у каждой строки
i0 = [0, 1]
i1 = [1, 2]
print(a[i0, i1]) # array([2, 7])

# Изменение массивов через списочную индексацию
a = np.arange(7) # array([0, 1, 2, 3, 4, 5, 6])
a[[0, 4, 6]] = [-1, -2, -3] # array([-1,  1,  2,  3, -2,  5, -3])
# Если в списке индексов имеются повторы, то новое значение будет соответствовать последнему значению
a[[0, 0, 0, 1]] = [1, 2, 3, 100] # array([  3, 100,   2,   3,  -2,   5,  -3])
a[[0, 0, 0]] = a[[0, 0, 0]] + 3 # Здесь сначала будет выполнена операция списочного индексирования a[[0, 0, 0]],
# а уже потом добавлено значение 3
a[0] = a[0] + 3
a[[0, 0, 1, 2]] += 1 # array([  7, 101,  3,   3,  -2,   5,  -3])
a[[0, 1, 2]] += 1 # array([  7, 101,   3,   3,  -2,   5,  -3])
